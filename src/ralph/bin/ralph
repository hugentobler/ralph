#!/usr/bin/env bash
set -euo pipefail

# Parse command-line arguments
WEB_ENABLED="0"
PROVIDER_FLAG=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    --web)
      WEB_ENABLED="1"
      shift
      ;;
    --codex)
      PROVIDER_FLAG="codex"
      shift
      ;;
    --claude)
      PROVIDER_FLAG="claude"
      shift
      ;;
    --help|-h)
      echo "Usage: ralph [OPTIONS]"
      echo ""
      echo "Options:"
      echo "  --codex   Use codex CLI"
      echo "  --claude  Use claude CLI"
      echo "  --web     Enable web search and fetch capabilities"
      echo "  --help    Show this help message"
      echo ""
      echo "Auto-detects provider if not specified (prefers codex)."
      echo "Requires RALPH.md in current directory."
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      echo "Use --help for usage information" >&2
      exit 1
      ;;
  esac
done

WORKDIR="$PWD"
PROMPT_FILE="$WORKDIR/RALPH.md"
COMPLETION_PROMISE="<promise>DONE</promise>"
COMPLETION_EXIT_CODE="10"
MAX_ITERATIONS="8"
RETRY_COUNT="3"
RETRY_SLEEP="10"
HEARTBEAT_SECS="30"
HEARTBEAT_FIRST_SECS="5"
HEARTBEAT_LINES="30"
HEARTBEAT_SUMMARY="1"
RUN_START_EPOCH="$(date +%s)"
SUMMARY_TIMEOUT_SECS="$((HEARTBEAT_SECS - 2))"
if [[ "$SUMMARY_TIMEOUT_SECS" -lt 1 ]]; then
  SUMMARY_TIMEOUT_SECS="1"
fi

# Locate packaged helpers (resolve symlinks for bun global installs).
SCRIPT_PATH="${BASH_SOURCE[0]}"
if command -v readlink >/dev/null 2>&1; then
  while [[ -L "$SCRIPT_PATH" ]]; do
    link_target="$(readlink "$SCRIPT_PATH")"
    if [[ "$link_target" == /* ]]; then
      SCRIPT_PATH="$link_target"
    else
      SCRIPT_PATH="$(cd "$(dirname "$SCRIPT_PATH")" && cd "$(dirname "$link_target")" && pwd)/$(basename "$link_target")"
    fi
  done
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
LIB_DIR="$SCRIPT_DIR/../lib"

# Source provider abstraction
# shellcheck source=../lib/providers.sh
source "$LIB_DIR/providers.sh"

PYTHON_BIN="$(command -v python3 || true)"
BUN_BIN="$(command -v bun || true)"
NODE_BIN="$(command -v node || true)"

if [[ -z "$PYTHON_BIN" && -z "$BUN_BIN" && -z "$NODE_BIN" ]]; then
  echo "ralph requires python3 or node/bun for JSONL parsing" >&2
  exit 1
fi

if [[ ! -f "$PROMPT_FILE" ]]; then
  echo "Prompt file not found in current directory: $PROMPT_FILE" >&2
  exit 1
fi

# Detect and validate provider
if [[ -n "$PROVIDER_FLAG" ]]; then
  PROVIDER="$PROVIDER_FLAG"
else
  PROVIDER="$(detect_provider)"
fi
if [[ -z "$PROVIDER" ]]; then
  echo "No supported AI CLI found. Install codex or claude." >&2
  exit 1
fi

if ! validate_provider "$PROVIDER"; then
  exit 1
fi

CLI_CMD="$(get_cli_command "$PROVIDER")"
echo "using $PROVIDER" >&2

# Build the prompt with a completion protocol.
base_prompt="$(cat "$PROMPT_FILE")"
base_prompt="${base_prompt}

When the task is fully complete:
1) Summarize changes made (files + intent).
2) List remaining TODOs (if any), or say \"No remaining TODOs.\"
Then output exactly: ${COMPLETION_PROMISE}
"

# Build provider-specific arguments (as strings, not arrays, to avoid set -u issues)
exec_args="$(build_exec_args "$PROVIDER" "$WEB_ENABLED")"
summary_args="$(build_summary_args "$PROVIDER")"

if [[ "$WEB_ENABLED" == "1" ]]; then
  echo "Web search/fetch: enabled" >&2
fi

# Logs + output tracking.
LOG_DIR="$WORKDIR/.ralph"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/loop-$(date +"%Y%m%d-%H%M%S").log"
PIPE_PGID=""
HEARTBEAT_PID=""

cleanup() {
  if [[ -n "${PIPE_PGID}" ]]; then
    kill -- -"$PIPE_PGID" 2>/dev/null || true
  fi
  if [[ -n "${HEARTBEAT_PID}" ]]; then
    # Send TERM to let the heartbeat's trap run stop_spinner gracefully
    kill -TERM "$HEARTBEAT_PID" 2>/dev/null || true
    # Wait briefly for clean shutdown
    sleep 0.2
    # Force kill any remaining children (spinner)
    pkill -9 -P "$HEARTBEAT_PID" 2>/dev/null || true
    # Force kill the heartbeat if still alive
    kill -9 "$HEARTBEAT_PID" 2>/dev/null || true
    wait "$HEARTBEAT_PID" 2>/dev/null || true
    HEARTBEAT_PID=""
  fi
  # Clear spinner line
  printf '\r\033[2K' >&2
}

trap cleanup INT TERM EXIT

# Select the JSONL parser runtime.
if [[ -n "$PYTHON_BIN" ]]; then
  PARSER_CMD=("$PYTHON_BIN" -u "$LIB_DIR/parse_jsonl.py")
elif [[ -n "$BUN_BIN" ]]; then
  PARSER_CMD=("$BUN_BIN" run --silent "$LIB_DIR/parse_jsonl.mjs")
else
  PARSER_CMD=("$NODE_BIN" "$LIB_DIR/parse_jsonl.mjs")
fi

# Loop until completion promise or max iterations.
for ((i=1; i<=MAX_ITERATIONS; i++)); do
  if [[ "$i" -eq 1 ]]; then
    echo "--- ralph loop $i/$MAX_ITERATIONS ---" | tee -a "$LOG_FILE"
  else
    elapsed_secs=$(( $(date +%s) - RUN_START_EPOCH ))
    elapsed_fmt="$(printf '%d:%02d' $((elapsed_secs / 60)) $((elapsed_secs % 60)))"
    echo "" | tee -a "$LOG_FILE"
    echo "--- ralph loop $i/$MAX_ITERATIONS | ${elapsed_fmt} ---" | tee -a "$LOG_FILE"
  fi

  attempt=1
  while :; do
    # Capture the pipeline's exit status from the backgrounded subshell.
    status_file="$(mktemp -p /tmp ralph-status.XXXXXX)"

    start_heartbeat() {
      (
        run_with_timeout() {
          local timeout_secs="$1"
          shift
          if command -v timeout >/dev/null 2>&1; then
            timeout "${timeout_secs}" "$@"
            return
          fi
          perl -e 'alarm shift; exec @ARGV' "$timeout_secs" "$@"
        }

        local spinner_pid=""
        start_spinner() {
          if [[ ! -t 2 ]]; then
            return
          fi
          if [[ -n "$spinner_pid" ]]; then
            return
          fi
          (
            local frame=0
            local frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
            while :; do
              printf '\r\033[2K%s' "${frames[$frame]}" >&2
              frame=$(((frame + 1) % ${#frames[@]}))
              sleep 0.12
            done
          ) &
          spinner_pid="$!"
        }

        stop_spinner() {
          if [[ -n "$spinner_pid" ]]; then
            kill "$spinner_pid" 2>/dev/null || true
            wait "$spinner_pid" 2>/dev/null || true
            spinner_pid=""
            printf '\r\033[2K' >&2
          fi
        }

        trap 'stop_spinner; exit 0' INT TERM
        sleep "$HEARTBEAT_FIRST_SECS"
        start_spinner
        local last_line_count=0
        local last_summary=""
        while :; do
          local line_count=0
          if [[ -f "$LOG_FILE" ]]; then
            line_count="$(wc -l < "$LOG_FILE" 2>/dev/null || echo 0)"
          fi
          local summary=""
          if [[ "$HEARTBEAT_SUMMARY" == "0" ]]; then
            summary="working"
          elif [[ "$line_count" -eq "$last_line_count" ]]; then
            summary="waiting (no new log lines)"
          else
            lines="$(tail -n "$HEARTBEAT_LINES" "$LOG_FILE" 2>/dev/null || true)"
            if [[ -n "$lines" ]]; then
              prompt=$'Summarize the following log lines in one concise sentence of fewer than 10 words prioritising them in reverse. These are logs of a cli coding agent progress. Be factual, no quotes, no markdown, no bullets, no need to mention the agent. If there are none, say "no new log lines".\n\nLOG LINES:\n'"$lines"
              # Use provider-specific summary command
              # shellcheck disable=SC2086
              summary="$(run_with_timeout "$SUMMARY_TIMEOUT_SECS" "$CLI_CMD" \
                $summary_args \
                "$prompt" 2>/dev/null | awk 'NF { line=$0 } END { if (line) print line }')" || true
            fi
            if [[ -n "$summary" ]]; then
              last_line_count="$line_count"
              last_summary="$summary"
            fi
          fi
          if [[ -z "$summary" ]]; then
            summary="${last_summary:-working}"
          fi
          stop_spinner
          echo "- $summary" | tee -a "$LOG_FILE" >&2
          start_spinner
          sleep "$HEARTBEAT_SECS"
        done
      ) &
      HEARTBEAT_PID="$!"
    }

    stop_heartbeat() {
      if [[ -n "${HEARTBEAT_PID}" ]]; then
        kill "$HEARTBEAT_PID" 2>/dev/null || true
        wait "$HEARTBEAT_PID" 2>/dev/null || true
        HEARTBEAT_PID=""
      fi
    }

    run_pipeline() {
      set +e
      # Configure the parser via env so Python/Bun stay in sync.
      export RALPH_RUN_START_EPOCH="$RUN_START_EPOCH"
      export RALPH_FINAL_OUTPUT_HEADER="1"
      export RALPH_COMPLETION_PROMISE="$COMPLETION_PROMISE"
      export RALPH_COMPLETION_EXIT_CODE="$COMPLETION_EXIT_CODE"
      export RALPH_PROVIDER="$PROVIDER"
      # Parser appends raw JSONL to the log to avoid tee buffering.
      export RALPH_RAW_LOG_PATH="$LOG_FILE"
      stop_heartbeat
      start_heartbeat
      if [[ "$attempt" -gt 1 ]]; then
        echo "Retry $attempt/$RETRY_COUNT" | tee -a "$LOG_FILE"
      fi
      # shellcheck disable=SC2086
      "$CLI_CMD" $exec_args "$base_prompt" \
        2>>"$LOG_FILE" | "${PARSER_CMD[@]}"
      stop_heartbeat

      pipe_status=("${PIPESTATUS[@]}")
      # Parser is always the last stage in the pipeline.
      if (( ${#pipe_status[@]} > 0 )); then
        parser_status="${pipe_status[$(( ${#pipe_status[@]} - 1 ))]}"
      else
        parser_status=1
      fi
      printf '%s %s' "${pipe_status[0]}" "$parser_status" > "$status_file"
    }

    run_pipeline &
    PIPE_PGID="$!"
    wait "$PIPE_PGID"
    PIPE_PGID=""
    read -r cli_status parser_status < "$status_file" 2>/dev/null || {
      cli_status=1
      parser_status=1
    }
    rm -f "$status_file"

    if [[ "${parser_status:-1}" -eq "$COMPLETION_EXIT_CODE" ]]; then
      exit 0
    fi

    # Fallback: re-scan the log with the same parser in case streaming missed it.
    RALPH_HEARTBEAT_SECS="$HEARTBEAT_SECS" \
      RALPH_COMPLETION_PROMISE="$COMPLETION_PROMISE" \
      RALPH_COMPLETION_EXIT_CODE="$COMPLETION_EXIT_CODE" \
      RALPH_PROVIDER="$PROVIDER" \
      "${PARSER_CMD[@]}" < "$LOG_FILE" >/dev/null 2>&1
    log_parser_status=$?
    if [[ "$log_parser_status" -eq "$COMPLETION_EXIT_CODE" ]]; then
      exit 0
    fi

    if [[ $cli_status -eq 0 ]]; then
      break
    fi

    if [[ "$attempt" -ge "$RETRY_COUNT" ]]; then
      echo "$CLI_CMD failed after $RETRY_COUNT attempts (see $LOG_FILE)" | tee -a "$LOG_FILE"
      exit $cli_status
    fi

    echo "$CLI_CMD failed with status $cli_status; retrying in ${RETRY_SLEEP}s" \
      | tee -a "$LOG_FILE"
    sleep "$RETRY_SLEEP"
    attempt=$((attempt + 1))
  done

done

echo "Max iterations reached without completion promise: $COMPLETION_PROMISE" | tee -a "$LOG_FILE"
exit 2
